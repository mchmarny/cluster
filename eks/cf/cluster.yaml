AWSTemplateFormatVersion: '2010-09-09'
Description: EKS cluster with VPC, subnets, node groups, and add-ons

# =====================================================================================================================
# Parameters
# =====================================================================================================================
Parameters:
  ClusterName:
    Type: String
    Description: EKS cluster name
  VpcCidr:
    Type: String
    Default: 10.0.0.0/16
  # Secondary VPC CIDR for EKS CNI custom networking (pod ENI subnets)
  SecondaryVpcCidr:
    Type: String
    Default: 100.65.0.0/16
  
  # EKS Configuration
  EksVersion:
    Type: String
    Default: "1.33"
    Description: EKS Kubernetes version
  VpcCniVersion:
    Type: String
    Default: "v1.20.1-eksbuild.1"
    Description: VPC CNI add-on version
  CoreDnsVersion:
    Type: String
    Default: "v1.12.2-eksbuild.4"
    Description: CoreDNS add-on version
  ControlPlaneAllowedCidrs:
    Type: CommaDelimitedList
    Default: "0.0.0.0/0"
    Description: CIDR blocks allowed to access EKS API server endpoint (public internet ranges only)

  # Node Group Instance Types
  SystemNodeInstanceTypes:
    Type: CommaDelimitedList
    Default: "m7a.48xlarge"
    Description: Instance types for system node group (AMD64 architecture)
  CpuWorkerNodeInstanceTypes:
    Type: CommaDelimitedList
    Default: "m8g.16xlarge"
    Description: Instance types for CPU worker node group (AMD64 architecture)
  GpuWorkerNodeInstanceTypes:
    Type: CommaDelimitedList
    Default: "p6e-gb200.36xlarge"
    Description: Instance types for GPU worker node group (ARM64 architecture)

  # Node Group Scaling Configuration
  SystemNodeDesiredSize:
    Type: Number
    Default: 3
    Description: Desired number of system nodes
  CpuWorkerNodeDesiredSize:
    Type: Number
    Default: 2
    Description: Desired number of CPU worker nodes
  GpuWorkerNodeDesiredSize:
    Type: Number
    Default: 2
    Description: Desired number of GPU worker nodes

  # Node Group Disk Size
  SystemNodeDiskSize:
    Type: Number
    Default: 500
    Description: Disk size in GB for system nodes
  CpuWorkerNodeDiskSize:
    Type: Number
    Default: 500
    Description: Disk size in GB for CPU worker nodes
  GpuWorkerNodeDiskSize:
    Type: Number
    Default: 500
    Description: Disk size in GB for GPU worker nodes

  # Node Group AMI Configuration (Required)
  SystemNodeAmiId:
    Type: String
    Description: AMI ID for system nodes (required - specify exact AMI for your region)
  CpuWorkerNodeAmiId:
    Type: String  
    Description: AMI ID for CPU worker nodes (required - specify exact AMI for your region)
  GpuWorkerNodeAmiId:
    Type: String  
    Description: AMI ID for GPU worker nodes (required - specify exact AMI for your region)

  # Public subnets (larger /24 for LB/NAT capacity)
  PublicSubnet1Cidr:
    Type: String
    Default: 10.0.1.0/24
  PublicSubnet2Cidr:
    Type: String
    Default: 10.0.2.0/24

  # "System" private subnets (for control-plane addons, controllers, etc.)
  SystemSubnet1Cidr:
    Type: String
    Default: 10.0.4.0/22
  SystemSubnet2Cidr:
    Type: String
    Default: 10.0.8.0/22

  # Worker private subnets (one per AZ; sized for nodes)
  WorkerSubnet1Cidr:
    Type: String
    Default: 10.0.128.0/18
  WorkerSubnet2Cidr:
    Type: String
    Default: 10.0.192.0/18

  # Pod ENI subnets carved from SecondaryVpcCidr (one per AZ)
  PodSubnet1Cidr:
    Type: String
    Default: 100.65.0.0/18
  PodSubnet2Cidr:
    Type: String
    Default: 100.65.64.0/18

  # Custom Bootstrap Scripts
  SystemNodeBootstrapScript:
    Type: String
    Default: |
      #!/bin/bash
      set -o xtrace
      export SERVICE_IPV4_CIDR="172.20.0.0/16"
      
      CLUSTER_NAME="${ClusterName}"
      TOKEN=$(curl -fsS -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
      REGION=$(curl -fsS -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/placement/region)
      AZ=$(curl -fsS -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/placement/availability-zone)

      for i in {1..3}; do
          CLUSTER_CA=$(aws eks describe-cluster \
            --region $REGION \
            --name $CLUSTER_NAME \
            --query "cluster.certificateAuthority.data" \
            --output text 2>/dev/null)
          CLUSTER_ENDPOINT=$(aws eks describe-cluster \
            --region $REGION \
            --name $CLUSTER_NAME \
            --query "cluster.endpoint" \
            --output text 2>/dev/null)
          
          if [[ -n "$CLUSTER_CA" && -n "$CLUSTER_ENDPOINT" ]]; then
              break
          fi
          
          sleep 10
      done

      if [[ -z "$CLUSTER_CA" || -z "$CLUSTER_ENDPOINT" ]]; then
          echo "ERROR: Failed to retrieve cluster information after 3 attempts"
          exit 1
      fi

      echo "CA: $CLUSTER_CA"
      echo "Endpoint: $CLUSTER_ENDPOINT"

      /etc/eks/bootstrap.sh $CLUSTER_NAME \
        --ip-family ipv4 \
        --b64-cluster-ca $CLUSTER_CA \
        --apiserver-endpoint $CLUSTER_ENDPOINT \
        --kubelet-extra-args \
          "--node-labels=nodeGroup=system,dedicated=system-workload,k8s.amazonaws.com/eniConfig=system-${AZ}" \
          "--register-with-taints=dedicated=system-workload:NoSchedule,dedicated=system-workload:NoExecute"

    Description: Cloud init script for system nodes
    
  CpuWorkerNodeBootstrapScript:
    Type: String
    Default: |
      #!/bin/bash
      set -o xtrace
      export SERVICE_IPV4_CIDR="172.20.0.0/16"
      
      CLUSTER_NAME="${ClusterName}"
      TOKEN=$(curl -fsS -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
      REGION=$(curl -fsS -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/placement/region)
      AZ=$(curl -fsS -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/placement/availability-zone)

      for i in {1..3}; do
          CLUSTER_CA=$(aws eks describe-cluster \
            --region $REGION \
            --name $CLUSTER_NAME \
            --query "cluster.certificateAuthority.data" \
            --output text 2>/dev/null)
          CLUSTER_ENDPOINT=$(aws eks describe-cluster \
            --region $REGION \
            --name $CLUSTER_NAME \
            --query "cluster.endpoint" \
            --output text 2>/dev/null)
          
          if [[ -n "$CLUSTER_CA" && -n "$CLUSTER_ENDPOINT" ]]; then
              break
          fi
          
          sleep 10
      done

      if [[ -z "$CLUSTER_CA" || -z "$CLUSTER_ENDPOINT" ]]; then
          echo "ERROR: Failed to retrieve cluster information after 3 attempts"
          exit 1
      fi

      echo "CA: $CLUSTER_CA"
      echo "Endpoint: $CLUSTER_ENDPOINT"

      /etc/eks/bootstrap.sh $CLUSTER_NAME \
        --ip-family ipv4 \
        --b64-cluster-ca $CLUSTER_CA \
        --apiserver-endpoint $CLUSTER_ENDPOINT \
        --kubelet-extra-args \
          "--node-labels=nodeGroup=cpu-workload,dedicated=cpu-workload,k8s.amazonaws.com/eniConfig=workload-${AZ}" \
          "--register-with-taints=dedicated=workload-workload:NoSchedule,dedicated=workload-workload:NoExecute"

    Description: Cloud init script for CPU worker nodes

  GpuWorkerNodeBootstrapScript:
    Type: String
    Default: |
      #!/bin/bash
      set -o xtrace
      export SERVICE_IPV4_CIDR="172.20.0.0/16"
      
      CLUSTER_NAME="${ClusterName}"
      TOKEN=$(curl -fsS -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
      REGION=$(curl -fsS -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/placement/region)
      AZ=$(curl -fsS -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/placement/availability-zone)

      for i in {1..3}; do
          CLUSTER_CA=$(aws eks describe-cluster \
            --region $REGION \
            --name $CLUSTER_NAME \
            --query "cluster.certificateAuthority.data" \
            --output text 2>/dev/null)
          CLUSTER_ENDPOINT=$(aws eks describe-cluster \
            --region $REGION \
            --name $CLUSTER_NAME \
            --query "cluster.endpoint" \
            --output text 2>/dev/null)
          
          if [[ -n "$CLUSTER_CA" && -n "$CLUSTER_ENDPOINT" ]]; then
              break
          fi
          
          sleep 10
      done

      if [[ -z "$CLUSTER_CA" || -z "$CLUSTER_ENDPOINT" ]]; then
          echo "ERROR: Failed to retrieve cluster information after 3 attempts"
          exit 1
      fi

      echo "CA: $CLUSTER_CA"
      echo "Endpoint: $CLUSTER_ENDPOINT"

      /etc/eks/bootstrap.sh $CLUSTER_NAME \
        --ip-family ipv4 \
        --b64-cluster-ca $CLUSTER_CA \
        --apiserver-endpoint $CLUSTER_ENDPOINT \
        --kubelet-extra-args \
          "--node-labels=nodeGroup=gpu-workload,dedicated=gpu-workload,k8s.amazonaws.com/eniConfig=workload-${AZ}" \
          "--register-with-taints=dedicated=workload-workload:NoSchedule,dedicated=workload-workload:NoExecute"

    Description: Cloud init script for GPU worker nodes

# =====================================================================================================================
# Resources
# =====================================================================================================================
Resources:
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: !Ref VpcCidr
      EnableDnsSupport: true
      EnableDnsHostnames: true
      Tags:
        - { Key: Name, Value: !Sub '${ClusterName}-vpc' }

  # Associate secondary IPv4 CIDR for EKS CNI custom networking
  VpcSecondaryCidr:
    Type: AWS::EC2::VPCCidrBlock
    Properties:
      VpcId: !Ref VPC
      CidrBlock: !Ref SecondaryVpcCidr

  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - { Key: Name, Value: !Sub '${ClusterName}-igw' }

  AttachGateway:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref VPC
      InternetGatewayId: !Ref InternetGateway

  # -----------------------
  # Public Subnets
  # -----------------------
  PublicSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Sub '${AWS::Region}a'
      CidrBlock: !Ref PublicSubnet1Cidr
      MapPublicIpOnLaunch: true
      Tags:
        - { Key: Name, Value: !Sub '${ClusterName}-public-1' }
        - { Key: kubernetes.io/role/elb, Value: '1' }
        - { Key: !Sub 'kubernetes.io/cluster/${ClusterName}', Value: shared }

  PublicSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Sub '${AWS::Region}b'
      CidrBlock: !Ref PublicSubnet2Cidr
      MapPublicIpOnLaunch: true
      Tags:
        - { Key: Name, Value: !Sub '${ClusterName}-public-2' }
        - { Key: kubernetes.io/role/elb, Value: '1' }
        - { Key: !Sub 'kubernetes.io/cluster/${ClusterName}', Value: shared }

  # -----------------------
  # System Private Subnets
  # -----------------------
  SystemSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Sub '${AWS::Region}a'
      CidrBlock: !Ref SystemSubnet1Cidr
      MapPublicIpOnLaunch: false
      Tags:
        - { Key: Name, Value: !Sub '${ClusterName}-system-1' }
        - { Key: kubernetes.io/role/internal-elb, Value: '1' }
        - { Key: !Sub 'kubernetes.io/cluster/${ClusterName}', Value: shared }

  SystemSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Sub '${AWS::Region}b'
      CidrBlock: !Ref SystemSubnet2Cidr
      MapPublicIpOnLaunch: false
      Tags:
        - { Key: Name, Value: !Sub '${ClusterName}-system-2' }
        - { Key: kubernetes.io/role/internal-elb, Value: '1' }
        - { Key: !Sub 'kubernetes.io/cluster/${ClusterName}', Value: shared }

  # -----------------------
  # Worker Private Subnets
  # -----------------------
  WorkerSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Sub '${AWS::Region}a'
      CidrBlock: !Ref WorkerSubnet1Cidr
      MapPublicIpOnLaunch: false
      Tags:
        - { Key: Name, Value: !Sub '${ClusterName}-worker-1' }
        - { Key: kubernetes.io/role/internal-elb, Value: '1' }
        - { Key: !Sub 'kubernetes.io/cluster/${ClusterName}', Value: shared }
        - { Key: karpenter.sh/discovery, Value: !Ref ClusterName }

  WorkerSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Sub '${AWS::Region}b'
      CidrBlock: !Ref WorkerSubnet2Cidr
      MapPublicIpOnLaunch: false
      Tags:
        - { Key: Name, Value: !Sub '${ClusterName}-worker-2' }
        - { Key: kubernetes.io/role/internal-elb, Value: '1' }
        - { Key: !Sub 'kubernetes.io/cluster/${ClusterName}', Value: shared }
        - { Key: karpenter.sh/discovery, Value: !Ref ClusterName }

  # -----------------------
  # Pod ENI Subnets (secondary CIDR; one per AZ)
  # -----------------------
  PodSubnet1:
    Type: AWS::EC2::Subnet
    DependsOn: VpcSecondaryCidr
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Sub '${AWS::Region}a'
      CidrBlock: !Ref PodSubnet1Cidr
      MapPublicIpOnLaunch: false
      Tags:
        - { Key: Name, Value: !Sub '${ClusterName}-pod-eni-1' }
        - { Key: !Sub 'kubernetes.io/cluster/${ClusterName}', Value: shared }

  PodSubnet2:
    Type: AWS::EC2::Subnet
    DependsOn: VpcSecondaryCidr
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Sub '${AWS::Region}b'
      CidrBlock: !Ref PodSubnet2Cidr
      MapPublicIpOnLaunch: false
      Tags:
        - { Key: Name, Value: !Sub '${ClusterName}-pod-eni-2' }
        - { Key: !Sub 'kubernetes.io/cluster/${ClusterName}', Value: shared }

  # ------------
  # NAT per AZ
  # ------------
  NatEIP1:
    Type: AWS::EC2::EIP
    Properties: { Domain: vpc }

  NatGateway1:
    Type: AWS::EC2::NatGateway
    Properties:
      AllocationId: !GetAtt NatEIP1.AllocationId
      SubnetId: !Ref PublicSubnet1
      Tags: [ { Key: Name, Value: !Sub '${ClusterName}-nat-1' } ]

  NatEIP2:
    Type: AWS::EC2::EIP
    Properties: { Domain: vpc }

  NatGateway2:
    Type: AWS::EC2::NatGateway
    Properties:
      AllocationId: !GetAtt NatEIP2.AllocationId
      SubnetId: !Ref PublicSubnet2
      Tags: [ { Key: Name, Value: !Sub '${ClusterName}-nat-2' } ]

  # ----------------
  # Route Tables
  # ----------------
  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags: [ { Key: Name, Value: !Sub '${ClusterName}-public-rt' } ]

  PublicRoute:
    Type: AWS::EC2::Route
    DependsOn: AttachGateway
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway

  PublicSubnet1RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties: { SubnetId: !Ref PublicSubnet1, RouteTableId: !Ref PublicRouteTable }

  PublicSubnet2RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties: { SubnetId: !Ref PublicSubnet2, RouteTableId: !Ref PublicRouteTable }

  # System RTs
  SystemRouteTable1:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags: [ { Key: Name, Value: !Sub '${ClusterName}-system-rt-1' } ]

  SystemRoute1Default:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref SystemRouteTable1
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref NatGateway1

  SystemSubnet1Assoc:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties: { SubnetId: !Ref SystemSubnet1, RouteTableId: !Ref SystemRouteTable1 }

  SystemRouteTable2:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags: [ { Key: Name, Value: !Sub '${ClusterName}-system-rt-2' } ]

  SystemRoute2Default:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref SystemRouteTable2
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref NatGateway2

  SystemSubnet2Assoc:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties: { SubnetId: !Ref SystemSubnet2, RouteTableId: !Ref SystemRouteTable2 }

  # Worker RTs - used by both Worker and Pod subnets in the same AZ
  WorkerRt1:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags: [ { Key: Name, Value: !Sub '${ClusterName}-worker-rt-1' } ]

  WorkerRt1Default:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref WorkerRt1
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref NatGateway1

  WorkerSubnet1Assoc:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties: { SubnetId: !Ref WorkerSubnet1, RouteTableId: !Ref WorkerRt1 }

  PodSubnet1Assoc:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties: { SubnetId: !Ref PodSubnet1, RouteTableId: !Ref WorkerRt1 }

  WorkerRt2:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags: [ { Key: Name, Value: !Sub '${ClusterName}-worker-rt-2' } ]

  WorkerRt2Default:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref WorkerRt2
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref NatGateway2

  WorkerSubnet2Assoc:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties: { SubnetId: !Ref WorkerSubnet2, RouteTableId: !Ref WorkerRt2 }

  PodSubnet2Assoc:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties: { SubnetId: !Ref PodSubnet2, RouteTableId: !Ref WorkerRt2 }

  # ---------------------------
  # Interface Endpoint Security
  # ---------------------------
  EndpointSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Allow HTTPS to VPC interface endpoints
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - { IpProtocol: tcp, FromPort: 443, ToPort: 443, CidrIp: !Ref VpcCidr }
        - { IpProtocol: tcp, FromPort: 443, ToPort: 443, CidrIp: !Ref SecondaryVpcCidr }

  # ----------------
  # VPC Endpoints
  # ----------------
  VpcS3GatewayEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      VpcId: !Ref VPC
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.s3'
      VpcEndpointType: Gateway
      RouteTableIds:
        - !Ref WorkerRt1
        - !Ref WorkerRt2
        - !Ref SystemRouteTable1
        - !Ref SystemRouteTable2

  VpcEcrApiEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      VpcId: !Ref VPC
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.ecr.api'
      VpcEndpointType: Interface
      SubnetIds:
        - !Ref WorkerSubnet1   # AZ1
        - !Ref WorkerSubnet2   # AZ2
      PrivateDnsEnabled: true
      SecurityGroupIds: [ !Ref EndpointSecurityGroup ]

  VpcEcrDkrEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      VpcId: !Ref VPC
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.ecr.dkr'
      VpcEndpointType: Interface
      SubnetIds:
        - !Ref WorkerSubnet1   # AZ1
        - !Ref WorkerSubnet2   # AZ2
      PrivateDnsEnabled: true
      SecurityGroupIds: [ !Ref EndpointSecurityGroup ]

  VpcStsEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      VpcId: !Ref VPC
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.sts'
      VpcEndpointType: Interface
      SubnetIds:
        - !Ref WorkerSubnet1
        - !Ref WorkerSubnet2
      PrivateDnsEnabled: true
      SecurityGroupIds: [ !Ref EndpointSecurityGroup ]

  VpcLogsEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      VpcId: !Ref VPC
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.logs'
      VpcEndpointType: Interface
      SubnetIds:
        - !Ref WorkerSubnet1
        - !Ref WorkerSubnet2
      PrivateDnsEnabled: true
      SecurityGroupIds: [ !Ref EndpointSecurityGroup ]

  VpcEc2Endpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      VpcId: !Ref VPC
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.ec2'
      VpcEndpointType: Interface
      SubnetIds:
        - !Ref WorkerSubnet1
        - !Ref WorkerSubnet2
      PrivateDnsEnabled: true
      SecurityGroupIds: [ !Ref EndpointSecurityGroup ]

  # --------------
  # VPC Flow Logs
  # --------------
  VpcFlowLogsGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/${ClusterName}/vpc-flowlogs'
      RetentionInDays: 14

  VpcFlowLogsRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal: { Service: [ vpc-flow-logs.amazonaws.com ] }
            Action: sts:AssumeRole
      Policies:
        - PolicyName: vpc-flow-logs
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                  - logs:DescribeLogGroups
                  - logs:DescribeLogStreams
                Resource: !GetAtt VpcFlowLogsGroup.Arn

  VpcFlowLog:
    Type: AWS::EC2::FlowLog
    Properties:
      DeliverLogsPermissionArn: !GetAtt VpcFlowLogsRole.Arn
      LogGroupName: !Ref VpcFlowLogsGroup
      ResourceId: !Ref VPC
      ResourceType: VPC
      TrafficType: ALL

  # =====================================================================================================================
  # KS Cluster & IAM
  # =====================================================================================================================

  EksServiceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: eks.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonEKSClusterPolicy

  EksNodeGroupRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy
        - arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy
        - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly

  EksClusterSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: EKS Cluster Security Group
      VpcId: !Ref VPC
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0
      Tags:
        - Key: Name
          Value: !Sub '${ClusterName}-cluster-sg'

  EksCluster:
    Type: AWS::EKS::Cluster
    Properties:
      Name: !Ref ClusterName
      Version: !Ref EksVersion
      RoleArn: !GetAtt EksServiceRole.Arn
      AccessConfig:
        AuthenticationMode: API_AND_CONFIG_MAP
        BootstrapClusterCreatorAdminPermissions: true
      ResourcesVpcConfig:
        SecurityGroupIds:
          - !Ref EksClusterSecurityGroup
        SubnetIds:
          - !Ref SystemSubnet1
          - !Ref SystemSubnet2
          - !Ref WorkerSubnet1
          - !Ref WorkerSubnet2
        EndpointPrivateAccess: true
        EndpointPublicAccess: true
        PublicAccessCidrs: !Ref ControlPlaneAllowedCidrs
      Logging:
        ClusterLogging:
          EnabledTypes:
            - Type: api
            - Type: audit
            - Type: authenticator
            - Type: controllerManager
            - Type: scheduler
      Tags:
        - Key: Name
          Value: !Ref ClusterName

  # =====================================================================================================================
  # Launch Templates
  # =====================================================================================================================
  SystemNodeLaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    Properties:
      LaunchTemplateName: !Sub '${ClusterName}-system-lt'
      LaunchTemplateData:
        ImageId: !Ref SystemNodeAmiId
        SecurityGroupIds:
          - !Ref EksClusterSecurityGroup
        BlockDeviceMappings:
          - DeviceName: /dev/sda1
            Ebs:
              VolumeSize: !Ref SystemNodeDiskSize
              VolumeType: gp3
              DeleteOnTermination: true
        UserData:
          Fn::Base64: !Sub 
            - |
              #!/bin/bash
              set -o xtrace
              
              SCRIPT_CONTENT="${BootstrapScriptPath}"
              
              # Check if it's a URL
              if [[ "$SCRIPT_CONTENT" =~ ^https?:// ]]; then
                  echo "Downloading bootstrap script from $SCRIPT_CONTENT"
                  curl -fsSL "$SCRIPT_CONTENT" | bash -s -- "${ClusterName}"
              # Check if it starts with shebang (inline script content)
              elif [[ "$SCRIPT_CONTENT" =~ ^#! ]]; then
                  echo "Executing inline bootstrap script"
                  echo "$SCRIPT_CONTENT" | bash -s -- "${ClusterName}"
              else
                  echo "ERROR: Invalid bootstrap script format"
                  echo "Expected either a URL (https://...) or inline script content"
                  echo "Got: ${!SCRIPT_CONTENT:0:100}"
                  exit 1
              fi
            - BootstrapScriptPath: !Ref SystemNodeBootstrapScript
        TagSpecifications:
          - ResourceType: instance
            Tags:
              - Key: Name
                Value: !Sub '${ClusterName}-system-node'
              - Key: !Sub 'kubernetes.io/cluster/${ClusterName}'
                Value: owned

  CpuWorkerNodeLaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    Properties:
      LaunchTemplateName: !Sub '${ClusterName}-cpu-worker-lt'
      LaunchTemplateData:
        ImageId: !Ref CpuWorkerNodeAmiId
        SecurityGroupIds:
          - !Ref EksClusterSecurityGroup
        BlockDeviceMappings:
          - DeviceName: /dev/sda1
            Ebs:
              VolumeSize: !Ref CpuWorkerNodeDiskSize
              VolumeType: gp3
              DeleteOnTermination: true
        UserData:
          Fn::Base64: !Sub 
            - |
              #!/bin/bash
              set -o xtrace
              
              SCRIPT_CONTENT="${BootstrapScriptPath}"
              
              # Check if it's a URL
              if [[ "$SCRIPT_CONTENT" =~ ^https?:// ]]; then
                  echo "Downloading bootstrap script from $SCRIPT_CONTENT"
                  curl -fsSL "$SCRIPT_CONTENT" | bash -s -- "${ClusterName}"
              # Check if it starts with shebang (inline script content)
              elif [[ "$SCRIPT_CONTENT" =~ ^#! ]]; then
                  echo "Executing inline bootstrap script"
                  echo "$SCRIPT_CONTENT" | bash -s -- "${ClusterName}"
              else
                  echo "ERROR: Invalid bootstrap script format"
                  echo "Expected either a URL (https://...) or inline script content"
                  echo "Got: ${!SCRIPT_CONTENT:0:100}"
                  exit 1
              fi
            - BootstrapScriptPath: !Ref CpuWorkerNodeBootstrapScript
        TagSpecifications:
          - ResourceType: instance
            Tags:
              - Key: Name
                Value: !Sub '${ClusterName}-cpu-worker-node'
              - Key: !Sub 'kubernetes.io/cluster/${ClusterName}'
                Value: owned

  GpuWorkerNodeLaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    Properties:
      LaunchTemplateName: !Sub '${ClusterName}-gpu-worker-lt'
      LaunchTemplateData:
        ImageId: !Ref GpuWorkerNodeAmiId
        SecurityGroupIds:
          - !Ref EksClusterSecurityGroup
        BlockDeviceMappings:
          - DeviceName: /dev/sda1
            Ebs:
              VolumeSize: !Ref GpuWorkerNodeDiskSize
              VolumeType: gp3
              DeleteOnTermination: true
        UserData:
          Fn::Base64: !Sub 
            - |
              #!/bin/bash
              set -o xtrace
              
              SCRIPT_CONTENT="${BootstrapScriptPath}"
              
              # Check if it's a URL
              if [[ "$SCRIPT_CONTENT" =~ ^https?:// ]]; then
                  echo "Downloading bootstrap script from $SCRIPT_CONTENT"
                  curl -fsSL "$SCRIPT_CONTENT" | bash -s -- "${ClusterName}"
              # Check if it starts with shebang (inline script content)
              elif [[ "$SCRIPT_CONTENT" =~ ^#! ]]; then
                  echo "Executing inline bootstrap script"
                  echo "$SCRIPT_CONTENT" | bash -s -- "${ClusterName}"
              else
                  echo "ERROR: Invalid bootstrap script format"
                  echo "Expected either a URL (https://...) or inline script content"
                  echo "Got: ${!SCRIPT_CONTENT:0:100}"
                  exit 1
              fi
            - BootstrapScriptPath: !Ref GpuWorkerNodeBootstrapScript
        TagSpecifications:
          - ResourceType: instance
            Tags:
              - Key: Name
                Value: !Sub '${ClusterName}-gpu-worker-node'
              - Key: !Sub 'kubernetes.io/cluster/${ClusterName}'
                Value: owned

  # System Node Group
  EksSystemNodeGroup:
    Type: AWS::EKS::Nodegroup
    Properties:
      ClusterName: !Ref EksCluster
      NodegroupName: system
      NodeRole: !GetAtt EksNodeGroupRole.Arn
      Subnets:
        - !Ref SystemSubnet1
        - !Ref SystemSubnet2
      InstanceTypes: !Ref SystemNodeInstanceTypes
      ScalingConfig:
        DesiredSize: !Ref SystemNodeDesiredSize
        MinSize: !Ref SystemNodeDesiredSize
        MaxSize: 10
      AmiType: CUSTOM
      LaunchTemplate:
        Id: !Ref SystemNodeLaunchTemplate
        Version: !GetAtt SystemNodeLaunchTemplate.LatestVersionNumber
      CapacityType: ON_DEMAND
      Labels:
        nodeGroup: system
        architecture: amd64
      Tags:
        Name: !Sub '${ClusterName}-system-nodes'

  # CPU Worker Node Group
  EksCpuWorkerNodeGroup:
    Type: AWS::EKS::Nodegroup
    Properties:
      ClusterName: !Ref EksCluster
      NodegroupName: cpu-worker
      NodeRole: !GetAtt EksNodeGroupRole.Arn
      Subnets:
        - !Ref WorkerSubnet1
        - !Ref WorkerSubnet2
      InstanceTypes: !Ref CpuWorkerNodeInstanceTypes
      ScalingConfig:
        DesiredSize: !Ref CpuWorkerNodeDesiredSize
        MinSize: !Ref CpuWorkerNodeDesiredSize
        MaxSize: !Ref CpuWorkerNodeDesiredSize
      AmiType: CUSTOM
      LaunchTemplate:
        Id: !Ref CpuWorkerNodeLaunchTemplate
        Version: !GetAtt CpuWorkerNodeLaunchTemplate.LatestVersionNumber
      CapacityType: ON_DEMAND
      Labels:
        nodeGroup: cpu-worker
        architecture: amd64
      Tags:
        Name: !Sub '${ClusterName}-cpu-worker-nodes'

  # GPU Worker Node Group
  EksGpuWorkerNodeGroup:
    Type: AWS::EKS::Nodegroup
    Properties:
      ClusterName: !Ref EksCluster
      NodegroupName: gpu-worker
      NodeRole: !GetAtt EksNodeGroupRole.Arn
      Subnets:
        - !Ref WorkerSubnet1
        - !Ref WorkerSubnet2
      InstanceTypes: !Ref GpuWorkerNodeInstanceTypes
      ScalingConfig:
        DesiredSize: !Ref GpuWorkerNodeDesiredSize
        MinSize: !Ref GpuWorkerNodeDesiredSize
        MaxSize: !Ref GpuWorkerNodeDesiredSize
      AmiType: CUSTOM
      LaunchTemplate:
        Id: !Ref GpuWorkerNodeLaunchTemplate
        Version: !GetAtt GpuWorkerNodeLaunchTemplate.LatestVersionNumber
      CapacityType: ON_DEMAND
      Labels:
        nodeGroup: gpu-worker
        architecture: arm64
      Tags:
        Name: !Sub '${ClusterName}-gpu-worker-nodes'

  # EKS Add-ons
  VpcCniAddon:
    Type: AWS::EKS::Addon
    Properties:
      ClusterName: !Ref EksCluster
      AddonName: vpc-cni
      AddonVersion: !Ref VpcCniVersion
      ResolveConflicts: OVERWRITE

  CoreDnsAddon:
    Type: AWS::EKS::Addon
    Properties:
      ClusterName: !Ref EksCluster
      AddonName: coredns
      AddonVersion: !Ref CoreDnsVersion
      ResolveConflicts: OVERWRITE

# =====================================================================================================================
# Outputs
# =====================================================================================================================
Outputs:
  VpcId:
    Description: VPC ID
    Value: !Ref VPC
    Export: { Name: !Sub '${ClusterName}:VpcId' }

  VpcPrimaryCidr:
    Description: VPC primary CIDR
    Value: !Ref VpcCidr
    Export: { Name: !Sub '${ClusterName}:VpcPrimaryCidr' }

  VpcSecondaryCidr:
    Description: VPC secondary CIDR (for pod ENIs)
    Value: !Ref SecondaryVpcCidr
    Export: { Name: !Sub '${ClusterName}:VpcSecondaryCidr' }

  PublicSubnetIds:
    Description: Public subnet IDs (comma-separated)
    Value: !Join [ ",", [ !Ref PublicSubnet1, !Ref PublicSubnet2 ] ]
    Export: { Name: !Sub '${ClusterName}:PublicSubnetIds' }

  SystemSubnetIds:
    Description: System private subnet IDs (comma-separated)
    Value: !Join [ ",", [ !Ref SystemSubnet1, !Ref SystemSubnet2 ] ]
    Export: { Name: !Sub '${ClusterName}:SystemSubnetIds' }

  WorkerSubnetIds:
    Description: Worker private subnet IDs (comma-separated)
    Value: !Join [ ",", [ !Ref WorkerSubnet1, !Ref WorkerSubnet2 ] ]
    Export: { Name: !Sub '${ClusterName}:WorkerSubnetIds' }

  PodEniSubnetIds:
    Description: Pod ENI subnet IDs (secondary CIDR, comma-separated)
    Value: !Join [ ",", [ !Ref PodSubnet1, !Ref PodSubnet2 ] ]
    Export: { Name: !Sub '${ClusterName}:PodEniSubnetIds' }

  EksClusterName:
    Description: EKS cluster name
    Value: !Ref EksCluster
    Export: { Name: !Sub '${ClusterName}:EksClusterName' }

  EksClusterEndpoint:
    Description: EKS cluster API server endpoint
    Value: !GetAtt EksCluster.Endpoint
    Export: { Name: !Sub '${ClusterName}:EksClusterEndpoint' }

  EksClusterArn:
    Description: EKS cluster ARN
    Value: !GetAtt EksCluster.Arn
    Export: { Name: !Sub '${ClusterName}:EksClusterArn' }

  EksOidcIssuerUrl:
    Description: EKS OIDC issuer URL for IRSA
    Value: !GetAtt EksCluster.OpenIdConnectIssuerUrl
    Export: { Name: !Sub '${ClusterName}:EksOidcIssuerUrl' }